// User interface. The user interface is composed of an 2004 LCD and a standard
// rotary encoder with a push button. The gives us a rather simple input model
//
// |----------------|  publish   |------------|  notifies   |------------------|
// | Rot State Poll |----------->| UI Event Q |------------>| UI Event handler |
// |----------------|            |------------|             |------------------|
//                                                            |    |    |    |
//      -------------------------------------------------------    |    |    |
//      |                 ------------------------------------------    |    |
//      |                 |                  ----------------------------    |
//      |                 |                  |                   -------------
//      |                 |                  |                   |
//      V                 V                  V                   V
// |----------|     |-----------|     |-------------|     |------------|
// | Rot Left |     | Rot Right |     | Short Press |     | Long Press |
// |----------|     |-----------|     |-------------|     |------------|
//
//
// Input is generated by polling the rotary encoder state at regular intervals.
// When it rotary encoder driver deems that an event has occured it publishes
// this event to the UI event Q which then wakes the UI event handler which
// calls the corresponding state function handle i.e. short_press(), etc..
// Now the input above drives the UI state as shown below:
//
// |---------|-------------------------|------------|-------------------------|
// | In Menu |                         | In Command |                         |
// |---------|                         |------------|                         |
// |                                   |                                      |
// |           CMD List                |                     Line Buff        |
// |          |---------|       |-------------|             |----------|      |                                             
// | Cursor-->|  cmd_0  |------>| Short Press |-- Cursor--->|  line_0  |---   |
// |    ^     |  cmd_1  |       |  (CMD INI)  |     ^       |  line_1  |  |   |
// |    |     |  cmd_2  |       |-------------|     |       |  line_2  |  |   |
// |    |     |  ...    |              |            |       |    ...   |  |   |
// |    |     |  cmd_n  |              |            |       |  line_n  |  |   |
// |    |     |---------|              |            |       |----------|  |   |
// |    |                        |------------|     |                     |   |
// |    |------------------------| Long Press |     |           -----------   |
// |                             | (CMD FINI) |     |           v             |
// |                             |------------|     |   |-------------|       |
// |                                   |            ----| Short Press |       |
// |                                   |                |   (CMD CB)  |       |
// |                                   |                |-------------|       |
// |-----------------------------------|--------------------------------------|
//
//
// The UI state is a set of different modes. In menu and in command. In the 
// "in menu" mode you see a list of commands to be executed. Rot Left and Rot
// Right move the cursor up and down the screen. Based on the cursor position
// and size of screen the display is updated in a logical manner. A
// short press on this mode executes a commands init function and switches the
// mode to in command where a line buffer is seen and scrolled through instead
// of a list of commands. Its on the command to clear the buffer before use. 
// Now subsequent short presses pass the index in the line buffer the cursor is
// pointing too and execute that commands call back function. Finally a long
// press brings you back to the in menu mode and calls the commands fini 
// function. API functions are provided for manipulating the UI state.
//
// NOTE access to the UI state via API functions are not guarded i.e. anyone
// or command can call them regardless of whether that function was executing
// it is up to the user to make sure that the commands fini functions kills all
// future access to the UI state.
//
// CONFIG) Dont forget to set the following in menuconfig. Mostly need to worry
//         if registering  too many commands, line buffer overflow, or the UI
//         event handler is taking up to much cpu time
//                * UI_NUM_CMDS
//                * UI_NUM_LINE_BUFF
//                * UI_EVENT_Q_SIZE
//                * CONFIG_UI_EVENT_HNDLR_PRIO
//

#pragma once

#include <stdint.h>

typedef void (*command_cb_t)(void);
typedef void (*on_press_cb_t)(uint8_t line_index);

//*****************************************************************************
// init_user_interface: To init the user interface a few high level tasks are
//                      done
//
//  1) Malloc CMD list, the Line Buffer, and the call back lists. Note this
//     could and ideally should statically allocated but one we are low on 
//     static memory and two this introduces the possibility of having this
//     component be nixed in the event we do not have an LCD or rotary
//
//  2) Create an even queue for rotoary encoder events and create a task to
//     handle them
//
//  3) Init the LCD and the rotary encoder components
//
//  4) Reset the screen, home and cursor positions, etc.
//
//*****************************************************************************
void init_user_interface(void);

void add_ui_cmd(char* name, command_cb_t cmd_init, on_press_cb_t on_press_cb, command_cb_t cmd_fini);

// Setters and getters for zee line buff
char* get_from_line_buffer(uint8_t line_num);
void push_to_line_buffer(uint8_t line_num, char* line);

// Based on the current cursor pos, line index and buffer contents update the 
// lcd
void update_display(void);

// Use this to update just one line on the screen. The passed index is the
// index in line buff. Must be on screen or will not do anything. Must also
// be called from not in_menu context
void update_line(uint8_t i);

// Just zeros out the cursor pos and index within the line buffer
void home_screen_pos(void);

// Dont allow the cursor to move
void lock_cursor(void);

void unlock_cursor(void);
void set_cursor(uint8_t i);

//*****************************************************************************
// Test driver functions to export to the REPL. All take in no args and always
// succeed.
//*****************************************************************************

int do_rot_l(int argc, char** argv);      // Calls rot_left cb in ui driver
int do_rot_r(int argc, char** argv);      // Calls rot_right cb in ui driver
int do_press(int argc, char** argv);      // Calls short_press in ui driver
int do_long_press(int argc, char** argv); // Calls long_press in ui driver